#!/bin/bash
set -e
set -o pipefail

OCP_CLUSTER_NAME=@@{ocp_cluster_name}@@
OCP_HUB_CLUSTER_NAME=@@{ocp_hub_cluster_name}@@

ENABLE_REDHAT_ADVANCED_CLUSTER_MGMT=@@{enable_redhat_advanced_cluster_management}@@
IMPORT_OCP_MANAGED_CLUSTER=@@{import_ocp_managed_cluster}@@

if [[ "${ENABLE_REDHAT_ADVANCED_CLUSTER_MGMT}" == "false" ]] && [[ "${IMPORT_OCP_MANAGED_CLUSTER}" == "true" ]]
then

## Enable ACM Operator via OperatorHub
echo "Importing Cluster into RedHat ACM Hub Cluster"

## These activities are applied directly to ocp hub cluster
export KUBECONFIG=$HOME/.kube/$OCP_HUB_CLUSTER_NAME.cfg

## The cluster name that is defined in CLUSTER_NAME is also used as the cluster namespace in the YAML file and commands
kubectl create ns $OCP_CLUSTER_NAME --dry-run=client -o yaml | kubectl apply -f -

## Create Managed Cluster Resource
cat <<EOF | kubectl apply --kubeconfig $HOME/.kube/$OCP_HUB_CLUSTER_NAME.cfg -f -
apiVersion: cluster.open-cluster-management.io/v1
kind: ManagedCluster
metadata:
  name: $OCP_CLUSTER_NAME
  labels:
    name: $OCP_CLUSTER_NAME
    cloud: auto-detect
    vendor: auto-detect
    cluster.open-cluster-management.io/clusterset: default
  annotations: {}
spec:
  hubAcceptsClient: true
EOF

## Wait for import secret to be created
while [[ -z $(kubectl get secret $OCP_CLUSTER_NAME-import -n $OCP_CLUSTER_NAME --kubeconfig $HOME/.kube/$OCP_HUB_CLUSTER_NAME.cfg 2>/dev/null) ]]; do
  echo "Waiting for $OCP_CLUSTER_NAME import secret to be created on OCP Hub Cluster: $OCP_HUB_CLUSTER_NAME..."
  sleep 10
done

## Obtain the klusterlet-crd yaml manifest that was generated by the import controller on your hub cluster and apply on managed cluster instance
kubectl get secret $OCP_CLUSTER_NAME-import -n $OCP_CLUSTER_NAME -o jsonpath={.data.crds\\.yaml} --kubeconfig $HOME/.kube/$OCP_HUB_CLUSTER_NAME.cfg | base64 -d | kubectl apply --kubeconfig $HOME/.kube/$OCP_CLUSTER_NAME.cfg -f -

## Obtain the import yaml manifest that was generated by the import controller on your hub cluster and apply on managed cluster instance
kubectl get secret $OCP_CLUSTER_NAME-import -n $OCP_CLUSTER_NAME -o jsonpath={.data.import\\.yaml} --kubeconfig $HOME/.kube/$OCP_HUB_CLUSTER_NAME.cfg | base64 -d | kubectl apply --kubeconfig $HOME/.kube/$OCP_CLUSTER_NAME.cfg -f -

## Validate JOINED and AVAILABLE status for the cluster that you are importing.
while [[ -z $(kubectl get deployment -l app=klusterlet -n open-cluster-management-agent --kubeconfig $HOME/.kube/$OCP_CLUSTER_NAME.cfg 2>/dev/null) ]]; do
  echo "Waiting for klusterlet deployment to be created..."
  sleep 10
done

kubectl wait --for=condition=available deployment -l app=klusterlet -n open-cluster-management-agent --kubeconfig $HOME/.kube/$OCP_CLUSTER_NAME.cfg

while [[ -z $(kubectl get deployment -l app=klusterlet-registration-agent -n open-cluster-management-agent --kubeconfig $HOME/.kube/$OCP_CLUSTER_NAME.cfg 2>/dev/null) ]]; do
  echo "Waiting for klusterlet-registration-agent deployment to be created..."
  sleep 10
done

kubectl wait --for=condition=available deployment -l app=klusterlet-registration-agent -n open-cluster-management-agent --kubeconfig $HOME/.kube/$OCP_CLUSTER_NAME.cfg

while [[ -z $(kubectl get deployment -l app=klusterlet-manifestwork-agent -n open-cluster-management-agent --kubeconfig $HOME/.kube/$OCP_CLUSTER_NAME.cfg 2>/dev/null) ]]; do
  echo "Waiting for klusterlet-manifestwork-agent deployment to be created..."
  sleep 10
done

kubectl wait --for=condition=available deployment -l app=klusterlet-manifestwork-agent -n open-cluster-management-agent --kubeconfig $HOME/.kube/$OCP_CLUSTER_NAME.cfg

## importing the klusterlet
cat <<EOF | kubectl apply --kubeconfig $HOME/.kube/$OCP_HUB_CLUSTER_NAME.cfg -f -
apiVersion: agent.open-cluster-management.io/v1
kind: KlusterletAddonConfig
metadata:
  name: ${OCP_CLUSTER_NAME}
  namespace: ${OCP_CLUSTER_NAME}
spec:
  clusterName: ${OCP_CLUSTER_NAME}
  clusterNamespace: ${OCP_CLUSTER_NAME}
  clusterLabels:
    name: ${OCP_CLUSTER_NAME}
    cloud: auto-detect
    vendor: auto-detect
    cluster.open-cluster-management.io/clusterset: default
  applicationManager:
    enabled: true
  policyController:
    enabled: true
  searchCollector:
    enabled: true
  certPolicyController:
    enabled: true
  iamPolicyController:
    enabled: true
EOF

## if there is existing clusterGroup=hub, then set to prod, otherwise, set to devel. Used by validated operator pattern.
[ -z $(kubectl get managedcluster -l clusterGroup=hub -o name) ] || kubectl label managedcluster ${OCP_CLUSTER_NAME} clusterGroup=prod -n open-cluster-management --overwrite
[ -z $(kubectl get managedcluster -l clusterGroup=prod -o name) ] || kubectl label managedcluster ${OCP_CLUSTER_NAME} clusterGroup=devel -n open-cluster-management --overwrite

fi
